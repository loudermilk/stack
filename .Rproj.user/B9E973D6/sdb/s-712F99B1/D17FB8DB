{
    "contents" : "## stack-main.R\n##\n## Main driver program for stackexchange analytics\n##\n## `main()` - will overwrite MySQL database `stackexchange` with\n## new data imported from SE *.xml files. It will create the following\n## tables: Tags, Users, Posts, Comments, Votes, PostLinks, PostHistorys,\n## and Badges.\n##\nlibrary(tm)\nsource(\"R/stack-xml.R\")\nsource(\"R/stack-mysql.R\")\n\n#' @title SE - StackExchange structure containing file_name reference and reader.\nSE <- list(Tags = list(file_name = \"se-data/Tags.xml\", reader = readStackXMLTags),\n           Users = list(file_name = \"se-data/Users.xml\", reader = readStackXMLUsers),\n           Posts = list(file_name = \"se-data/Posts.xml\", reader = readStackXMLPosts),\n           Comments = list(file_name = \"se-data/Comments.xml\", reader = readStackXMLComments),\n           Votes = list(file_name = \"se-data/Votes.xml\", reader = readStackXMLVotes),\n           PostLinks = list(file_name = \"se-data/PostLinks.xml\", reader = readStackXMLPostLinks),\n           PostHistorys = list(file_name = \"se-data/PostHistory.xml\", reader = readStackXMLPostHistorys),\n           Badges = list(file_name = \"se-data/Badges.xml\", reader = readStackXMLBadges))\n\n\n\n#' @title New StackExchange Corpus\n#'\n#' @param type character name of SE table (see SE_TABLES for supported table types)\n#' @return VCorpus\n#'\nnewSECorpus <- function(type) {\n  if (!type %in% names(SE)) {return(NULL)}\n\n  f <- SE[[type]]$file_name\n  r <- SE[[type]]$reader\n  createCorpus(f, r)\n}\n\n#' @title Create a corpus from file_name using reader\n#'\n#' @param file_name character name of xml file\n#' @param reader\n#' @return VCorpus\n#'\ncreateCorpus <- function(file_name, reader) {\n  mySource <- function(x){\n    tm::XMLSource(x, function(tree) XML::xmlChildren(XML::xmlRoot(tree)),\n              reader)\n  }\n  corpus <- tm::VCorpus(mySource(file_name))\n  return(corpus)\n}\n\n\n\n\n#' @title Exhaustive corpus search for attribute == value\n#'\n#' @param corpus\n#' @param attribute (e.g., \"DisplayName\")\n#' @param value (\"Brandon Loudermilk\")\n#'\n#' @return integer vector\nsearchCorpus <- function(corpus, attribute, value){\n  out_list <- c()\n  for (i in 1:length(corpus)) {\n    mt <- meta(corpus[[i]])\n    if (mt[[attribute]] == value) {\n      out_list <- c(out_list, i)\n    }\n  }\n  return(out_list)\n}\n\n\n#' @title Create data.frame of meta data from corpus\n#' @param corpus\n#' @return data.frame\n#'\ncorpusToDF <- function(corpus, add_content = FALSE) {\n  last <- length(corpus)\n\n  # assume that the doc with most meta info has *all* the meta info\n  # get list of number of meta entries\n  ll <- sapply(corpus, function(d) length(unlist(meta(d))))\n  indices <- which(max(ll) == ll)\n  ref_index <- indices[1]\n\n  ## determine number of columns\n  ref_doc <- corpus[[ref_index]] # has most meta-data\n\n  master_vec <- unlist(meta(ref_doc))\n  meta_col_headers <- names(master_vec)\n  meta_list <- list()\n  for (i in 1:last) {\n    doc <- corpus[[i]]\n    m <- meta(doc)\n    char_vec <- unlist(m)\n\n    ## normalize char_vec according to master_vec\n    new_vec <- master_vec\n    new_vec[1:length(new_vec)] <- NA\n    for (j in 1:length(char_vec)) {\n      n <- names(char_vec[j])[1]\n      v <- char_vec[j]\n      new_vec[n] <- v\n    }\n\n    if (add_content){\n      content <- content(doc)\n      if (length(content) > 0) {\n        new_vec[\"Content\"] <- content\n      } else {\n        new_vec[\"Content\"] <- NA\n      }\n    }\n\n    meta_list[[i]] <- new_vec\n  }\n\n  df <- t(data.frame(meta_list))\n  names(df) <- meta_col_headers\n  df <- as.data.frame(df)\n  return(df)\n}\n\n\n\n# searchCorpus(corpus, attribute, value)\n# dtm <- DocumentTermMatrix(corpus)\n# inspect(dtm[, grepl(\"Brandon\", dtm$dimnames$Terms)])\n# dtm$dimnames$Terms\n\n##\n## MAIN\n##\n\n##\n## Method #1\n##\n# type <- \"Badges\"\n# cc <- newSECorpus(type)\n# corpus <- cc[1:4]\n#\n# name <- \"posts\"\n# data <- corpusToDF(corpus)\n# data$id <- NULL # SQL isn't case sensitive\n# createSQLTable(con = DEF_CONNECTION, name = name, data = data)\n\n##\n## Method #2\n##\n# file_name <- xml_file <- \"data/PostLinks.xml\"\n# reader <- readStackXMLPostLinks\n# corpus <- createCorpus(file_name, reader)\n# meta(corpus[[1]])\n\n\nmain <- function() {\n  createStackExchangeSQLTables()\n}\n\n\n\n\n",
    "created" : 1464881114899.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1913707076",
    "id" : "D17FB8DB",
    "lastKnownWriteTime" : 1464881891,
    "path" : "~/repo/stack/R/stack-main.R",
    "project_path" : "R/stack-main.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}